//go:build go1.22

// Package openapiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapiv1

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ChatCompletionsResponseObject.
const (
	ChatCompletion ChatCompletionsResponseObject = "chat.completion"
)

// Defines values for ModelObject.
const (
	ModelObjectModel ModelObject = "model"
)

// Defines values for ModelListResponseObject.
const (
	List ModelListResponseObject = "list"
)

// Defines values for ResponsesOutputTextType.
const (
	OutputText ResponsesOutputTextType = "output_text"
)

// Defines values for ResponsesResponseObject.
const (
	Response ResponsesResponseObject = "response"
)

// ChatChoice defines model for ChatChoice.
type ChatChoice struct {
	FinishReason *string     `json:"finish_reason,omitempty"`
	Index        int         `json:"index"`
	Message      ChatMessage `json:"message"`
}

// ChatCompletionsRequest defines model for ChatCompletionsRequest.
type ChatCompletionsRequest struct {
	Messages []ChatMessage `json:"messages"`
	Model    string        `json:"model"`
	Stream   *bool         `json:"stream,omitempty"`
}

// ChatCompletionsResponse defines model for ChatCompletionsResponse.
type ChatCompletionsResponse struct {
	Choices []ChatChoice                  `json:"choices"`
	Id      string                        `json:"id"`
	Model   string                        `json:"model"`
	Object  ChatCompletionsResponseObject `json:"object"`
	Usage   *Usage                        `json:"usage,omitempty"`
}

// ChatCompletionsResponseObject defines model for ChatCompletionsResponse.Object.
type ChatCompletionsResponseObject string

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	Content string `json:"content"`
	Role    string `json:"role"`
}

// Model defines model for Model.
type Model struct {
	Id      string      `json:"id"`
	Object  ModelObject `json:"object"`
	OwnedBy *string     `json:"owned_by,omitempty"`
}

// ModelObject defines model for Model.Object.
type ModelObject string

// ModelListResponse defines model for ModelListResponse.
type ModelListResponse struct {
	Data   []Model                 `json:"data"`
	Object ModelListResponseObject `json:"object"`
}

// ModelListResponseObject defines model for ModelListResponse.Object.
type ModelListResponseObject string

// ResponsesInputItem defines model for ResponsesInputItem.
type ResponsesInputItem struct {
	union json.RawMessage
}

// ResponsesInputItem0 defines model for .
type ResponsesInputItem0 = string

// ResponsesInputItem1 defines model for .
type ResponsesInputItem1 = map[string]interface{}

// ResponsesOutputItem defines model for ResponsesOutputItem.
type ResponsesOutputItem struct {
	Content *[]ResponsesOutputText `json:"content,omitempty"`
	Id      string                 `json:"id"`
	Type    string                 `json:"type"`
}

// ResponsesOutputText defines model for ResponsesOutputText.
type ResponsesOutputText struct {
	Text string                  `json:"text"`
	Type ResponsesOutputTextType `json:"type"`
}

// ResponsesOutputTextType defines model for ResponsesOutputText.Type.
type ResponsesOutputTextType string

// ResponsesRequest defines model for ResponsesRequest.
type ResponsesRequest struct {
	Input  *ResponsesRequest_Input `json:"input,omitempty"`
	Model  string                  `json:"model"`
	Stream *bool                   `json:"stream,omitempty"`
}

// ResponsesRequestInput0 defines model for .
type ResponsesRequestInput0 = string

// ResponsesRequestInput1 defines model for .
type ResponsesRequestInput1 = []ResponsesInputItem

// ResponsesRequest_Input defines model for ResponsesRequest.Input.
type ResponsesRequest_Input struct {
	union json.RawMessage
}

// ResponsesResponse defines model for ResponsesResponse.
type ResponsesResponse struct {
	Id     string                  `json:"id"`
	Model  string                  `json:"model"`
	Object ResponsesResponseObject `json:"object"`
	Output []ResponsesOutputItem   `json:"output"`
	Usage  *Usage                  `json:"usage,omitempty"`
}

// ResponsesResponseObject defines model for ResponsesResponse.Object.
type ResponsesResponseObject string

// Usage defines model for Usage.
type Usage struct {
	CompletionTokens *int `json:"completion_tokens,omitempty"`
	PromptTokens     *int `json:"prompt_tokens,omitempty"`
	TotalTokens      *int `json:"total_tokens,omitempty"`
}

// CreateChatCompletionJSONRequestBody defines body for CreateChatCompletion for application/json ContentType.
type CreateChatCompletionJSONRequestBody = ChatCompletionsRequest

// CreateResponseJSONRequestBody defines body for CreateResponse for application/json ContentType.
type CreateResponseJSONRequestBody = ResponsesRequest

// AsResponsesInputItem0 returns the union data inside the ResponsesInputItem as a ResponsesInputItem0
func (t ResponsesInputItem) AsResponsesInputItem0() (ResponsesInputItem0, error) {
	var body ResponsesInputItem0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponsesInputItem0 overwrites any union data inside the ResponsesInputItem as the provided ResponsesInputItem0
func (t *ResponsesInputItem) FromResponsesInputItem0(v ResponsesInputItem0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponsesInputItem0 performs a merge with any union data inside the ResponsesInputItem, using the provided ResponsesInputItem0
func (t *ResponsesInputItem) MergeResponsesInputItem0(v ResponsesInputItem0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponsesInputItem1 returns the union data inside the ResponsesInputItem as a ResponsesInputItem1
func (t ResponsesInputItem) AsResponsesInputItem1() (ResponsesInputItem1, error) {
	var body ResponsesInputItem1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponsesInputItem1 overwrites any union data inside the ResponsesInputItem as the provided ResponsesInputItem1
func (t *ResponsesInputItem) FromResponsesInputItem1(v ResponsesInputItem1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponsesInputItem1 performs a merge with any union data inside the ResponsesInputItem, using the provided ResponsesInputItem1
func (t *ResponsesInputItem) MergeResponsesInputItem1(v ResponsesInputItem1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponsesInputItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponsesInputItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResponsesRequestInput0 returns the union data inside the ResponsesRequest_Input as a ResponsesRequestInput0
func (t ResponsesRequest_Input) AsResponsesRequestInput0() (ResponsesRequestInput0, error) {
	var body ResponsesRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponsesRequestInput0 overwrites any union data inside the ResponsesRequest_Input as the provided ResponsesRequestInput0
func (t *ResponsesRequest_Input) FromResponsesRequestInput0(v ResponsesRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponsesRequestInput0 performs a merge with any union data inside the ResponsesRequest_Input, using the provided ResponsesRequestInput0
func (t *ResponsesRequest_Input) MergeResponsesRequestInput0(v ResponsesRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponsesRequestInput1 returns the union data inside the ResponsesRequest_Input as a ResponsesRequestInput1
func (t ResponsesRequest_Input) AsResponsesRequestInput1() (ResponsesRequestInput1, error) {
	var body ResponsesRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponsesRequestInput1 overwrites any union data inside the ResponsesRequest_Input as the provided ResponsesRequestInput1
func (t *ResponsesRequest_Input) FromResponsesRequestInput1(v ResponsesRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponsesRequestInput1 performs a merge with any union data inside the ResponsesRequest_Input, using the provided ResponsesRequestInput1
func (t *ResponsesRequest_Input) MergeResponsesRequestInput1(v ResponsesRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponsesRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponsesRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /v1/chat/completions)
	CreateChatCompletion(w http.ResponseWriter, r *http.Request)

	// (GET /v1/models)
	ListModels(w http.ResponseWriter, r *http.Request)

	// (POST /v1/responses)
	CreateResponse(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateChatCompletion operation middleware
func (siw *ServerInterfaceWrapper) CreateChatCompletion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateChatCompletion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateResponse operation middleware
func (siw *ServerInterfaceWrapper) CreateResponse(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateResponse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/v1/chat/completions", wrapper.CreateChatCompletion)
	m.HandleFunc("GET "+options.BaseURL+"/v1/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/v1/responses", wrapper.CreateResponse)

	return m
}
